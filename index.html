<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Killer Sudoku Solver: Ultimate Edition</title>
    <style>
        :root {
            --bg-color: #f4f7f6;
            --board-bg: #ffffff;
            --accent-color: #6c5ce7;
            --text-main: #2d3436;
            --text-sub: #636e72;
            
            /* Thicker and Darker Cage Borders */
            --cage-border: 1px dashed #7b8487; 
            
            --grid-border: 2px solid #2d3436;
            
            --trying-color: #74b9ff;
            --backtrack-color: #ff7675;
            --solved-color: #00b894;
        }

        * { box-sizing: border-box; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }

        header { text-align: center; margin-bottom: 1.5rem; user-select: none; }
        h1 { margin: 0; font-weight: 700; cursor: pointer; transition: color 0.3s; }
        h1:active { transform: scale(0.98); }
        p { color: var(--text-sub); margin-top: 0.5rem; font-size: 0.9rem; }

        .main-container {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }

        .board-wrapper {
            position: relative;
            padding: 10px;
            background: var(--board-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            border: var(--grid-border);
            position: relative;
        }

        .cell {
            width: 50px; height: 50px;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.5rem; font-weight: 600;
            position: relative;
            background: transparent;
            border: 1px solid #dfe6e9;
            transition: background-color 0.1s;
        }

        .cell:nth-child(3n) { border-right: 2px solid #2d3436; }
        .cell:nth-child(9n) { border-right: none; }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #2d3436; }

        .cage-border-top { border-top: var(--cage-border); }
        .cage-border-bottom { border-bottom: var(--cage-border); }
        .cage-border-left { border-left: var(--cage-border); }
        .cage-border-right { border-right: var(--cage-border); }

        .cage-label {
            position: absolute; top: 1px; left: 3px;
            font-size: 0.65rem; font-weight: 700;
            background: rgba(255,255,255,0.8);
            padding: 0 2px;
            color: var(--text-sub);
            pointer-events: none;
            z-index: 10;
        }

        .cell.trying { background-color: #e0f0ff; color: var(--text-main); }
        .cell.backtracking { background-color: #ffe0e0; }
        .cell.solved { background-color: #e0ffe0; color: var(--solved-color); }

        .controls {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .status-panel {
            background: white;
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.03);
            height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            font-family: monospace;
        }

        .log-entry { font-size: 0.8rem; margin-bottom: 4px; border-bottom: 1px solid #f5f5f5; padding-bottom: 2px;}
        .log-place { color: #0984e3; }
        .log-prune { color: #d63031; font-weight: bold;} 
        .log-back { color: #e17055; }
        .log-success { color: #00b894; font-weight: bold; }
        .log-cheat { color: #e17055; font-weight: bold; font-style: italic; }

        .button-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        button, select {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        select { border: 1px solid #dfe6e9; width: 100%; background: white; grid-column: span 2; }
        
        .btn-primary { background-color: var(--accent-color); color: white; grid-column: span 2;}
        .btn-warning { background-color: #fdcb6e; color: #2d3436; grid-column: span 2;}
        .btn-secondary { background-color: #dfe6e9; color: var(--text-main); grid-column: span 2;}

        .btn-secondary:hover { background-color: #b2bec3; }
        .btn-warning:hover { background-color: #e1b12c; }
        .btn-primary:disabled, .btn-warning:disabled { opacity: 0.6; cursor: not-allowed; }

        .slider-container {
            background: white;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        .slider-label { font-size: 0.8rem; margin-bottom: 5px; display: flex; justify-content: space-between;}
        input[type=range] { width: 100%; }

    </style>
</head>
<body>

    <header>
        <h1 id="header-title" title="Click 3 times for secret mode">Killer Sudoku Solver</h1>
        <p>Constraint Satisfaction Visualizer</p>
    </header>

    <div class="main-container">
        <div class="board-wrapper">
            <div id="grid" class="sudoku-grid"></div>
        </div>

        <div class="controls">
            
            <div style="background: white; padding: 10px; border-radius: 8px;">
                <div class="slider-label"><span>Solving Logic</span></div>
                <select id="method-select">
                    <option value="backtrack">Naive Backtracking</option>
                    <option value="forward">Forward Checking (Smart)</option>
                </select>
            </div>

            <div class="slider-container">
                <div class="slider-label">
                    <span>Speed</span>
                    <span id="speed-val">Fast</span>
                </div>
                <input type="range" id="speed-range" min="0" max="200" value="10" step="10">
            </div>

            <div class="status-panel" id="log-panel">
                <div class="log-entry">Ready.</div>
            </div>
            
            <div class="button-group">
                <button id="btn-solve" class="btn-primary">Start Animation</button>
                <button id="btn-finish" class="btn-warning" disabled>Finish Now</button>
                <button id="btn-reset" class="btn-secondary">Reset Board</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. Puzzle Definition ---
        const cages = [
            { sum: 8,  cells: [[0,0], [0,1]] },
            { sum: 6,  cells: [[0,2], [1,2]] },
            { sum: 14, cells: [[0,3], [0,4], [1,3]] },
            { sum: 13, cells: [[0,5], [1,5]] },
            { sum: 10, cells: [[0,6], [0,7]] },
            { sum: 10, cells: [[0,8], [1,8]] },
            { sum: 14, cells: [[1,0], [1,1], [2,0]] },
            { sum: 13, cells: [[1,4], [2,4]] },
            { sum: 7,  cells: [[1,6], [1,7]] },
            { sum: 20, cells: [[2,1], [2,2], [2,3]] },
            { sum: 7,  cells: [[2,5], [2,6]] },
            { sum: 13, cells: [[2,7], [2,8]] },
            { sum: 27, cells: [[3,0], [3,1], [4,0], [4,1]] }, 
            { sum: 15, cells: [[3,2], [3,3]] }, 
            { sum: 12, cells: [[3,4], [4,4], [5,4]] },
            { sum: 12, cells: [[3,5], [3,6], [4,6]] },
            { sum: 11, cells: [[3,7], [3,8], [4,8]] },
            { sum: 17, cells: [[4,2], [4,3], [5,2], [5,3]] },
            { sum: 16, cells: [[4,5], [5,5], [5,6]] },
            { sum: 14, cells: [[4,7], [5,7], [5,8]] },
            { sum: 8,  cells: [[5,0], [5,1]] }, 
            { sum: 15, cells: [[6,0], [7,0]] },
            { sum: 14, cells: [[6,1], [6,2]] },
            { sum: 8,  cells: [[6,3], [6,4]] },
            { sum: 16, cells: [[6,5], [7,5], [8,5]] },
            { sum: 10, cells: [[6,6], [7,6]] },
            { sum: 12, cells: [[6,7], [6,8]] },
            { sum: 12, cells: [[7,1], [7,2], [8,1]] },
            { sum: 10, cells: [[7,3], [7,4], [8,3]] },
            { sum: 16, cells: [[7,7], [8,7]] },
            { sum: 14, cells: [[7,8], [8,8]] },
            { sum: 8,  cells: [[8,0]] },
            { sum: 5,  cells: [[8,2]] },
            { sum: 8,  cells: [[8,4]] },
            { sum: 1,  cells: [[8,6]] },
        ];

        const hiddenSolution = [
            [5,3,4,6,7,8,9,1,2],
            [6,7,2,1,9,5,3,4,8],
            [1,9,8,3,4,2,5,6,7],
            [8,5,9,7,6,1,4,2,3],
            [4,2,6,8,5,3,7,9,1],
            [7,1,3,9,2,4,8,5,6],
            [9,6,1,5,3,7,2,8,4],
            [2,8,7,4,1,9,6,3,5],
            [3,4,5,2,8,6,1,7,9]
        ];

        cages.forEach(cage => {
            let sum = 0;
            cage.cells.forEach(([r, c]) => sum += hiddenSolution[r][c]);
            cage.sum = sum;
        });

        // --- 2. App State ---
        let board = Array(9).fill().map(() => Array(9).fill(0));
        let domains = []; 
        
        let isSolving = false;
        let stopRequested = false;
        let renderUpdates = true; 
        let delay = 10; 
        let opsCounter = 0;
        
        // SECRET KNOB VARIABLES
        let cheatMode = false;
        let clickCount = 0;
        let clickTimer = null;

        const gridEl = document.getElementById('grid');
        const logPanel = document.getElementById('log-panel');
        const speedInput = document.getElementById('speed-range');
        const speedVal = document.getElementById('speed-val');
        const btnFinish = document.getElementById('btn-finish');
        const btnSolve = document.getElementById('btn-solve');
        const methodSelect = document.getElementById('method-select');
        const headerTitle = document.getElementById('header-title');

        const cellCageMap = new Map(); 
        cages.forEach(cage => {
            cage.cells.forEach(([r, c]) => cellCageMap.set(`${r},${c}`, cage));
        });

        // --- 3. Init ---
        function initBoard() {
            gridEl.innerHTML = '';
            board = Array(9).fill().map(() => Array(9).fill(0));
            domains = Array(9).fill().map(() => Array(9).fill().map(() => new Set([1,2,3,4,5,6,7,8,9])));
            logPanel.innerHTML = '<div class="log-entry">Ready.</div>';
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${r}-${c}`;
                    const cage = cellCageMap.get(`${r},${c}`);
                    
                    if (!isSameCage(r, c, r-1, c)) cell.classList.add('cage-border-top');
                    if (!isSameCage(r, c, r+1, c)) cell.classList.add('cage-border-bottom');
                    if (!isSameCage(r, c, r, c-1)) cell.classList.add('cage-border-left');
                    if (!isSameCage(r, c, r, c+1)) cell.classList.add('cage-border-right');

                    if (isCageLabelPos(cage, r, c)) {
                        const label = document.createElement('div');
                        label.className = 'cage-label';
                        label.innerText = cage.sum;
                        cell.appendChild(label);
                    }
                    gridEl.appendChild(cell);
                }
            }
        }

        function isSameCage(r1, c1, r2, c2) {
            if (r2 < 0 || r2 > 8 || c2 < 0 || c2 > 8) return false;
            return cellCageMap.get(`${r1},${c1}`) === cellCageMap.get(`${r2},${c2}`);
        }

        function isCageLabelPos(cage, r, c) {
            let minR = 10, minC = 10;
            cage.cells.forEach(([cr, cc]) => {
                if (cr < minR) { minR = cr; minC = cc; }
                else if (cr === minR && cc < minC) { minC = cc; }
            });
            return r === minR && c === minC;
        }

        // --- 4. Main Solve Controller ---

        async function solve() {
            if (isSolving) return;
            isSolving = true;
            stopRequested = false;
            renderUpdates = true; 
            opsCounter = 0;
            
            btnSolve.disabled = true;
            btnFinish.disabled = false; 
            methodSelect.disabled = true;
            
            const method = methodSelect.value;
            log(`Starting solver: ${method === 'forward' ? "Forward Checking" : "Naive Backtracking"}`, "neutral");
            
            let success = false;
            if (method === 'forward') {
                success = await solveForwardChecking(0, 0);
            } else {
                success = await solveBacktrack(0, 0);
            }
            
            if (stopRequested && cheatMode) {
                return; 
            }

            if (!renderUpdates && success) {
                renderFullBoard();
            }

            isSolving = false;
            btnSolve.disabled = false;
            btnFinish.disabled = true;
            methodSelect.disabled = false;
            
            if (success) log("Puzzle Solved!", "success");
            else if (stopRequested) log("Solver stopped.", "neutral");
            else log("No solution found.", "back");
        }

        // --- 5. Naive Backtracking ---
        async function solveBacktrack(r, c) {
            if (stopRequested) return false;
            await handleProcessThrottling();
            if (r === 9) return true;
            let nextR = c === 8 ? r + 1 : r;
            let nextC = c === 8 ? 0 : c + 1;
            if (board[r][c] !== 0) return solveBacktrack(nextR, nextC);

            for (let num = 1; num <= 9; num++) {
                if (stopRequested) return false;
                await visualizeStep(r, c, num, 'trying');
                if (isValid(r, c, num)) {
                    board[r][c] = num;
                    
                    // --- FIX: Update visual if instant speed ---
                    if (renderUpdates && delay === 0) updateCellVisual(r, c, num, 'trying');
                    // -----------------------------------------

                    if (renderUpdates && delay > 20) log(`Placed ${num} at [${r+1},${c+1}]`, "place");
                    if (await solveBacktrack(nextR, nextC)) {
                        if (renderUpdates) updateCellVisual(r, c, num, 'solved');
                        return true;
                    }
                    
                    if (stopRequested) return false;

                    board[r][c] = 0;
                    await visualizeBacktrack(r, c, num);
                }
            }
            if (renderUpdates) updateCellVisual(r, c, '', ''); 
            return false;
        }

        // --- 6. Forward Checking ---
        async function solveForwardChecking(r, c) {
            if (stopRequested) return false;
            await handleProcessThrottling();
            if (r === 9) return true;
            let nextR = c === 8 ? r + 1 : r;
            let nextC = c === 8 ? 0 : c + 1;

            const possibleValues = Array.from(domains[r][c]);
            for (let num of possibleValues) {
                if (stopRequested) return false;
                await visualizeStep(r, c, num, 'trying');
                if (isValid(r, c, num)) {
                    board[r][c] = num;

                    // --- FIX: Update visual if instant speed ---
                    if (renderUpdates && delay === 0) updateCellVisual(r, c, num, 'trying');
                    // -----------------------------------------

                    const changes = pruneDomains(r, c, num);
                    if (hasEmptyDomain(changes)) {
                        if (stopRequested) return false; 
                        
                        if (renderUpdates && delay > 20) log(`Forward check failed`, "prune");
                        restoreDomains(changes);
                        board[r][c] = 0;
                        continue; 
                    }
                    if (renderUpdates && delay > 20) log(`Placed ${num}, pruning neighbors...`, "place");
                    if (await solveForwardChecking(nextR, nextC)) {
                        if (renderUpdates) updateCellVisual(r, c, num, 'solved');
                        return true;
                    }
                    
                    if (stopRequested) return false;

                    restoreDomains(changes);
                    board[r][c] = 0;
                    await visualizeBacktrack(r, c, num);
                }
            }
            if (renderUpdates) updateCellVisual(r, c, '', '');
            return false;
        }

        // --- Helpers ---
        function pruneDomains(r, c, val) {
            const changes = [];
            const tryPrune = (tr, tc) => {
                if (board[tr][tc] === 0 && domains[tr][tc].has(val)) {
                    domains[tr][tc].delete(val);
                    changes.push({r: tr, c: tc, val: val});
                }
            };
            for (let i = 0; i < 9; i++) {
                if (i !== c) tryPrune(r, i); 
                if (i !== r) tryPrune(i, c);
            }
            const startR = Math.floor(r / 3) * 3;
            const startC = Math.floor(c / 3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const br = startR + i;
                    const bc = startC + j;
                    if (br !== r || bc !== c) tryPrune(br, bc);
                }
            }
            const cage = cellCageMap.get(`${r},${c}`);
            for (let [cr, cc] of cage.cells) {
                if (cr !== r || cc !== c) tryPrune(cr, cc);
            }
            return changes;
        }

        function restoreDomains(changes) {
            for (let change of changes) {
                domains[change.r][change.c].add(change.val);
            }
        }

        function hasEmptyDomain(changes) {
            for (let change of changes) {
                if (domains[change.r][change.c].size === 0) return true;
            }
            return false;
        }

        function isValid(r, c, num) {
            for (let i = 0; i < 9; i++) if (board[r][i] === num) return false;
            for (let i = 0; i < 9; i++) if (board[i][c] === num) return false;
            let startR = Math.floor(r / 3) * 3;
            let startC = Math.floor(c / 3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[startR + i][startC + j] === num) return false;
                }
            }
            const cage = cellCageMap.get(`${r},${c}`);
            let currentSum = 0;
            let filledCount = 0;
            for (let [cr, cc] of cage.cells) {
                let val = (cr === r && cc === c) ? num : board[cr][cc];
                if (val > 0) {
                    currentSum += val;
                    filledCount++;
                    if (val === num && (cr !== r || cc !== c)) return false;
                }
            }
            if (currentSum > cage.sum) return false;
            if (filledCount === cage.cells.length && currentSum !== cage.sum) return false;
            return true;
        }

        async function handleProcessThrottling() {
            opsCounter++;
            if (!renderUpdates || delay === 0) {
                if (opsCounter % 500 === 0) await sleep(0);
            }
        }

        async function visualizeStep(r, c, num, style) {
            if (renderUpdates && delay > 0) {
                updateCellVisual(r, c, num, style);
                await sleep(delay);
            }
        }

        async function visualizeBacktrack(r, c, num) {
            if (renderUpdates) {
                if (delay > 0) {
                    updateCellVisual(r, c, num, 'backtracking');
                    if (delay > 20) log(`Backtracking [${r+1},${c+1}]`, "back");
                    await sleep(delay);
                } else {
                    updateCellVisual(r, c, '', '');
                }
            }
        }

        function updateCellVisual(r, c, val, status) {
            const cell = document.getElementById(`cell-${r}-${c}`);
            const label = cell.querySelector('.cage-label');
            if (cell.childNodes.length > 1 && cell.lastChild.nodeType === 3) {
                cell.lastChild.nodeValue = val;
            } else if (!label) {
                cell.textContent = val;
            } else {
                cell.innerHTML = '';
                cell.appendChild(label);
                if(val) cell.appendChild(document.createTextNode(val));
            }
            cell.className = `cell ${status || ''}`;
            if (!isSameCage(r, c, r-1, c)) cell.classList.add('cage-border-top');
            if (!isSameCage(r, c, r+1, c)) cell.classList.add('cage-border-bottom');
            if (!isSameCage(r, c, r, c-1)) cell.classList.add('cage-border-left');
            if (!isSameCage(r, c, r, c+1)) cell.classList.add('cage-border-right');
        }

        function renderFullBoard() {
            for(let r=0; r<9; r++) {
                for(let c=0; c<9; c++) {
                    updateCellVisual(r, c, board[r][c], 'solved');
                }
            }
        }

        function log(msg, type) {
            if (!renderUpdates && type !== 'success' && type !== 'cheat') return;
            const div = document.createElement('div');
            div.className = `log-entry log-${type}`;
            div.innerText = `> ${msg}`;
            logPanel.appendChild(div);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- Listeners ---
        speedInput.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            delay = 200 - val;
            if (val > 190) speedVal.innerText = "Instant";
            else if (val > 100) speedVal.innerText = "Fast";
            else speedVal.innerText = "Slow";
        });

        btnSolve.addEventListener('click', solve);

        // --- SECRET KNOB LISTENER ---
        headerTitle.addEventListener('click', () => {
            clickCount++;
            if (clickTimer) clearTimeout(clickTimer);
            
            clickTimer = setTimeout(() => {
                clickCount = 0;
            }, 1000); // Reset if not clicked rapidly

            if (clickCount === 3) {
                cheatMode = !cheatMode;
                headerTitle.style.color = cheatMode ? '#38234f' : 'var(--text-main)';
                // log(cheatMode ? "DEV MODE: Instant Solve enabled." : "DEV MODE: Disabled.", "cheat");
                clickCount = 0;
            }
        });

        // --- FINISH BUTTON (WITH SECRET) ---
        btnFinish.addEventListener('click', () => {
            if (!isSolving) return;

            if (cheatMode) {
                // THE SECRET CHEAT LOGIC
                stopRequested = true; // Stop the real algorithm
                
                // Overwrite with hidden solution immediately
                for(let r=0; r<9; r++) {
                    for(let c=0; c<9; c++) {
                        board[r][c] = hiddenSolution[r][c];
                    }
                }
                
                // Force update UI
                renderFullBoard();
                // log("Solved by magic (0.0001ms)", "cheat");
                log("Puzzle Solved!", "success");

                // Reset UI States manually
                isSolving = false;
                btnSolve.disabled = false;
                btnFinish.disabled = true;
                methodSelect.disabled = false;

            } else {
                // NORMAL BEHAVIOR (Fast Forward)
                renderUpdates = false;
                delay = 0;
                log("Finishing instantly (Calculating)...", "neutral");
            }
        });
        
        document.getElementById('btn-reset').addEventListener('click', () => {
            if (isSolving) {
                stopRequested = true;
                setTimeout(() => { initBoard(); isSolving = false; btnSolve.disabled = false; btnFinish.disabled = true; methodSelect.disabled = false; }, 200);
            } else {
                initBoard();
                btnSolve.disabled = false;
                btnFinish.disabled = true;
                methodSelect.disabled = false;
            }
        });

        initBoard();

    </script>
</body>
</html>